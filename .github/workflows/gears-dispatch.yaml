name: DMC Component Manual Run

on:
  workflow_dispatch:
    inputs:
      os:
        description: The OS to build and test against
        type: choice
        default: focal
        options:
          - focal
          - mariner
          - rhel8
          - rhel9
      run_tests:
        description: "Boolean parameter to determine if tests should run"
        type: boolean
        default: true
      num_of_processes:
        description: "number of processes to use in the parallel sandwich run (\"-n 1\" means serial)"
        type: choice
        options:
          - "-n $(($(nproc) - 1))"
          - "-n 1"
      memory_leak:
        description: "1 if you want to run memory leak (use 1 process!), 0 if not (default)"
        type: choice
        default: "0"
        options:
          - "0"
          - "1"


concurrency:
  # github.workflow: the workflow name is used to generate the concurrency group (e.g. Workflow 1).
  # That allows you to have more than one different workflow (eg. workflow1.yaml and workflow2.yaml) triggered on the same event (e.g. a PR).
  # Otherwise, workflow1.yaml would cancel workflow2.yaml or viceversa.
  # github.event.pull_request.number: when the trigger event is a PR, it will use the PR number (e.g. workflow1-33).
  # github.ref: when the trigger is a push, it will use the branch or tag name (e.g. workflow1-branch1).
  #if cancel-in-progress is false, when a new workflow is triggered,
  # the currently running workflow won't be cancelled, and the new workflow will be queued until the previous one is done.
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  dmc_sandwich:
    uses: ./.github/workflows/dmc_sandwich.yaml
    with:
      os: ${{ inputs.os }}
      run_tests: ${{ inputs.run_tests }}
      memory_leak: ${{ inputs.memory_leak }}
      num_of_processes: ${{ inputs.num_of_processes }}
    secrets: inherit

